import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from 'app/store';
import { ApiResponse, CreateRoomDto, Room, Message, Chat } from 'digiroom-types';
import { axios } from 'utils/axios.util';

export interface RoomState {
  username: string;
  userId: string;
  room: Room | null;
  messages: Message[];
  state: 'disconnected' | 'failed' | 'joining' | 'joined';
}

const initialState: RoomState = {
  username: localStorage.getItem('username') ?? '',
  userId: localStorage.getItem('userId') ?? '',
  room: null,
  messages: [],
  state: 'disconnected', // => joining => joined
};

export const roomSlice = createSlice({
  name: 'room',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    changeCurrentVideo(
      state,
      action: PayloadAction<Pick<Room, 'currentVideoId' | 'currentVideo'>>,
    ) {
      if (!state.room) return;

      state.room = {
        ...state.room,
        ...action.payload,
      };
    },
    receiveMessage(state, action: PayloadAction<Message>) {
      state.messages.push(action.payload);
    },
    setUsername(state, action: PayloadAction<string>) {
      state.username = action.payload;
    },
    resetRoom(state) {
      state.state = 'disconnected';
      state.room = initialState.room;
      state.messages = initialState.messages;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder.addCase(createRoom.fulfilled, (state, action) => {
      state.state = 'disconnected';
      state.room = action.payload.data;
      state.userId = action.payload.data.users[0]._id; // bc its first user its ok
    });

    builder.addCase(getRoom.fulfilled, (state, action) => {
      state.room = action.payload.data;
    });

    builder.addCase(getChat.fulfilled, (state, action) => {
      state.messages = action.payload.data.messages;
    });

    builder
      .addCase(addUserToRoom.pending, (state, action) => {
        state.username = action.meta.arg.username;
      })
      .addCase(addUserToRoom.fulfilled, (state, action) => {
        const username = action.meta.arg.username;
        state.userId =
          action.payload.data.users.find(user => user.name === username)?._id ?? '';
        state.room = action.payload.data;
      });

    builder
      .addCase(joinRoom.pending, state => {
        state.state = 'joining';
      })
      .addCase(joinRoom.fulfilled, (state, action) => {
        state.state = 'joined';
      });
  },
});

const createRoom = createAsyncThunk(
  `${roomSlice.name}/createRoom`,
  async (payload: Omit<CreateRoomDto, 'username'>, { rejectWithValue, getState }) => {
    try {
      const username = (getState() as RootState).room.username;
      const { data } = await axios.post<ApiResponse<Room>>('/room', {
        ...payload,
        username,
      });

      const userId = data.data.users[0]._id;
      localStorage.setItem('userId', userId);

      return data;
    } catch (e) {
      return rejectWithValue(e);
    }
  },
);

const getRoom = createAsyncThunk(
  `${roomSlice.name}/getRoom`,
  async (roomName: string, { rejectWithValue }) => {
    try {
      const { data } = await axios.get<ApiResponse<Room>>(`/room/${roomName}`);

      return data;
    } catch (e) {
      return rejectWithValue(e);
    }
  },
);

const getChat = createAsyncThunk(
  `${roomSlice.name}/getChat`,
  async (roomName: string, { rejectWithValue }) => {
    try {
      const { data } = await axios.get<ApiResponse<Chat>>(`/room/${roomName}/chat`);

      return data;
    } catch (e) {
      return rejectWithValue(e);
    }
  },
);

const addUserToRoom = createAsyncThunk(
  `${roomSlice.name}/addUserToRoom`,
  async (
    { roomName, username }: { roomName: string; username: string },
    { rejectWithValue },
  ) => {
    try {
      const { data } = await axios.post<ApiResponse<Room>>(`/room/${roomName}/user`, {
        username,
      });

      const userId = data.data.users.find(user => user.name === username)?._id ?? '';

      localStorage.setItem('userId', userId);

      return data;
    } catch (e) {
      return rejectWithValue(e);
    }
  },
);

const joinRoom = createAsyncThunk(
  `${roomSlice.name}/joinRoom`,
  async (
    { roomName, callback }: { roomName: string; callback: (username: string) => void },
    { rejectWithValue, dispatch, getState },
  ) => {
    try {
      const username = (getState() as RootState).room.username;

      let roomData = await dispatch(getRoom(roomName)).unwrap();

      const isUsernameMember = roomData.data.users.find(user => user.name === username);

      if (!isUsernameMember) {
        const newRoomData = await dispatch(
          addUserToRoom({ roomName, username }),
        ).unwrap();

        roomData = newRoomData;
      }

      callback(username);

      const userId = roomData.data.users.find(user => user.name === username)?._id ?? '';

      localStorage.setItem('userId', userId);
    } catch (e) {
      return rejectWithValue(e);
    }
  },
);

export const roomActions = {
  ...roomSlice.actions,
  createRoom,
  getRoom,
  getChat,
  addUserToRoom,
  joinRoom,
};

export const roomReducer = roomSlice.reducer;
